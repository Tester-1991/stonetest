---
id: 1
title: 枚举
sidebar_position: 1
---
Python 的枚举（`Enum`）是 Python 3.4 引入的一个非常重要的特性，位于标准库 `enum` 模块中。

简单来说，**枚举就是一组符号名称（成员），它们绑定到唯一的、常量的值**。使用枚举的核心目的是为了**消除“魔术数字”和“魔术字符串”**，提高代码的可读性和可维护性。

---

### 1. 基础介绍

#### 定义枚举
最基础的用法是继承 `Enum` 类：

```python
from enum import Enum, auto

class OrderStatus(Enum):
    PENDING = 1    # 待处理
    PAID = 2       # 已支付
    SHIPPED = 3    # 已发货
    COMPLETED = 4  # 已完成
    CANCELED = 5   # 已取消

# 也可以使用 auto() 自动生成值（从1开始递增），当你不在乎具体数值时很有用
class Role(Enum):
    ADMIN = auto()
    USER = auto()
    GUEST = auto()
```

#### 基础操作
```python
# 1. 访问成员
print(OrderStatus.PAID)        # OrderStatus.PAID
print(OrderStatus.PAID.name)   # 'PAID' (名称)
print(OrderStatus.PAID.value)  # 2 (值)

# 2. 通过值获取枚举成员 (反向查找)
status = OrderStatus(2)
print(status == OrderStatus.PAID)  # True

# 3. 通过名称获取枚举成员
role = Role['ADMIN']

# 4. 遍历
for status in OrderStatus:
    print(f"{status.name}: {status.value}")

# 5. 比较
# 枚举成员是单例的，推荐使用 is 进行比较，虽然 == 也可以
if status is OrderStatus.PAID:
    print("订单已支付")
```

#### 特殊类型：`IntEnum` 和 `StrEnum`
*   **`IntEnum`**: 成员的值必须是整数，且可以直接与整数进行比较（`OrderStatus.PAID == 2` 为 True）。这在与数据库或 JSON 交互时非常有用。
*   **`StrEnum`** (Python 3.11+): 成员的值是字符串，且表现得像字符串。

---

### 2. 项目中的实际使用场景

在实际工程中，枚举主要用于处理**状态机、配置选项、错误码**等场景。

#### 场景一：数据库字段映射 (最常用)
在数据库中，为了节省空间，我们通常存 `TinyInt` (0, 1, 2) 或简短字符串 ('P', 'S', 'C')，但在代码中直接写 `if status == 1` 是大忌（魔术数字）。

**应用实例**：用户状态管理。

```python
from enum import IntEnum

class UserStatus(IntEnum):
    INACTIVE = 0
    ACTIVE = 1
    BANNED = 2
    DELETED = 3

def check_login(user_db_row):
    # 假设从数据库读出的 status 字段是整数 2
    current_status = UserStatus(user_db_row['status'])
    
    if current_status == UserStatus.BANNED:
        raise Exception("账号已被封禁")
    elif current_status == UserStatus.INACTIVE:
        raise Exception("账号未激活")
    
    # 业务逻辑...
```

#### 场景二：统一错误码与提示信息
后端 API 开发中，需要返回统一的错误码和错误信息。使用枚举可以将它们聚合管理。

**应用实例**：API 响应封装。

```python
from enum import Enum

class ErrorCode(Enum):
    # 定义格式：(错误码, 错误信息)
    SUCCESS = (0, "操作成功")
    PARAM_ERROR = (1001, "参数错误")
    USER_NOT_FOUND = (1002, "用户不存在")
    SYSTEM_ERROR = (9999, "系统繁忙")

    def __init__(self, code, msg):
        self.code = code
        self.msg = msg

# 使用
def api_response(error_enum: ErrorCode, data=None):
    return {
        "code": error_enum.code,
        "msg": error_enum.msg,
        "data": data
    }

# 调用
return api_response(ErrorCode.USER_NOT_FOUND)
```

#### 场景三：策略模式 (Strategy Pattern) 分发
当需要根据不同的类型执行不同的逻辑时，使用枚举配合字典映射，比写一堆 `if-else` 更优雅。

**应用实例**：支付渠道处理。

```python
class PaymentType(Enum):
    ALIPAY = "alipay"
    WECHAT = "wechat"
    PAYPAL = "paypal"

def pay_via_alipay(amount):
    print(f"支付宝支付: {amount}")

def pay_via_wechat(amount):
    print(f"微信支付: {amount}")

# 策略映射
PAYMENT_STRATEGIES = {
    PaymentType.ALIPAY: pay_via_alipay,
    PaymentType.WECHAT: pay_via_wechat,
}

def process_payment(pay_type: PaymentType, amount):
    # 避免了 if pay_type == ... elif ...
    handler = PAYMENT_STRATEGIES.get(pay_type)
    if handler:
        handler(amount)
    else:
        raise ValueError("不支持的支付方式")

# 调用
process_payment(PaymentType.ALIPAY, 100.0)
```

#### 场景四：限制函数参数输入 (类型安全)
Python 是动态语言，函数的参数很容易传错。使用枚举作为 Type Hint，可以明确告知调用者应该传什么值。

**应用实例**：文件导出格式。

```python
class ExportFormat(Enum):
    CSV = 'csv'
    XLSX = 'xlsx'
    JSON = 'json'

# 明确告诉调用者，fmt 参数必须是 ExportFormat 枚举之一
def export_data(data: list, fmt: ExportFormat):
    if fmt == ExportFormat.CSV:
        pass # 导出 CSV 逻辑
    elif fmt == ExportFormat.XLSX:
        pass # 导出 Excel 逻辑

# 调用者 IDE 会有提示，且代码意图非常清晰
export_data(my_data, ExportFormat.XLSX)
```

### 3. 总结：为什么要用枚举？

1.  **可读性 (Readability)**: `Status.COMPLETED` 比 `4` 容易理解得多。
2.  **可维护性 (Maintainability)**: 如果需要修改值（比如把 `PENDING` 从 1 改为 0），只需要在枚举类里改一处，所有引用的地方都会自动更新。
3.  **约束性 (Constraint)**: 枚举限制了变量的取值范围，防止传入无效的值（如传入了状态 `6`，但枚举里没有定义，转换时会直接报错，早发现早治疗）。
4.  **迭代能力**: 可以方便地列出所有选项（如下拉框的数据源）。